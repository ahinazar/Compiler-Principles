#use "code-gen.ml";;
open Code_Gen;;

let file_to_string f =
  let ic = open_in f in
  let s = really_input_string ic (in_channel_length ic) in
  close_in ic;
  s;;

let string_to_asts s = List.map Semantics.run_semantics
                         (Tag_Parser.tag_parse_expressions
                            (Reader.read_sexprs s));;

let primitive_names_to_labels = 
  ["boolean?", "is_boolean"; "float?", "is_float"; "integer?", "is_integer"; "pair?", "is_pair";
   "null?", "is_null"; "char?", "is_char"; "vector?", "is_vector"; "string?", "is_string";
   "procedure?", "is_procedure"; "symbol?", "is_symbol"; "string-length", "string_length";
   "string-ref", "string_ref"; "string-set!", "string_set"; "make-string", "make_string";
   "vector-length", "vector_length"; "vector-ref", "vector_ref"; "vector-set!", "vector_set";
   "make-vector", "make_vector"; "symbol->string", "symbol_to_string"; 
   "char->integer", "char_to_integer"; "integer->char", "integer_to_char"; "eq?", "is_eq";
   "+", "bin_add"; "*", "bin_mul"; "-", "bin_sub"; "/", "bin_div"; "<", "bin_lt"; "=", "bin_equ";
   "car", "car_func";"cdr", "cdr_func";"set-car!", "set_car";"set-cdr!", "set_cdr";"cons","cons_func";"apply","apply_func"];;

let rec is_in_fvar var ftbl = match ftbl,var with
| [] , _ -> false
| (name1,_)::tl ,(name2,_) when ((name1=name2) = true) -> true
| hd::tl,_-> is_in_fvar var tl ;;


let rec get_index_fvar table exp = match table with
  |[] -> -1
  |hd::tl -> match hd with
            | (sexp,offset) when sexp = exp ->   offset
            | _ -> get_index_fvar tl exp;;

let make_prologue consts_tbl fvars_tbl =
  let get_const_address const = (Printf.sprintf "const_tbl+%d" (get_offset_const_tbl consts_tbl const)) in
  let get_fvar_address const =(Printf.sprintf "fvar_tbl+%d * 8" (get_index_fvar fvars_tbl const)) in
  let make_primitive_closure (prim, label) =
"    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, " ^ label  ^ ")
    mov [" ^ (get_fvar_address prim)  ^ "], rax" in
  let make_constant (c, a, s) = s in
  
"
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include \"compiler.s\"

section .bss
malloc_pointer:
    resq 1

section .data
const_tbl:
" ^ (String.concat "\n" (List.map make_constant consts_tbl)) ^ "

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS " ^ get_const_address Void ^ "
%define SOB_NIL_ADDRESS " ^ get_const_address (Sexpr Nil) ^ "
%define SOB_FALSE_ADDRESS " ^ get_const_address (Sexpr (Bool false)) ^ "
%define SOB_TRUE_ADDRESS " ^ get_const_address (Sexpr (Bool true)) ^ "

fvar_tbl:
" ^ (String.concat "\n" (List.map (fun _ -> "dq T_UNDEFINED") fvars_tbl)) ^ "

section .text
global main
main:
    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp

    call code_fragment
    add rsp, 4*8
    ret

code_fragment:
    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
" ^ (String.concat "\n" (List.map make_primitive_closure (List.filter (fun x -> (is_in_fvar x fvars_tbl)) primitive_names_to_labels))) ^  ""
 ^ "
 
";;

let epilogue ="
car_func:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_PAIR
    jne .wrong_type
    mov rsi, PVAR(0)
    mov rax, [rsi+1]
    jmp .return

.wrong_type:
    mov rax,SOB_VOID_ADDRESS
.return:
    leave
    ret

set_car:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]
    cmp sil, T_PAIR
    jne .wrong_type
    mov rsi, PVAR(0)
    mov rcx, PVAR(1)
    mov [rsi+1], rcx
    jmp .return

.wrong_type:
    mov rax,SOB_VOID_ADDRESS
.return:
    mov rax,SOB_VOID_ADDRESS
    leave
    ret

cdr_func:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_PAIR
    jne .wrong_type
    mov rsi, PVAR(0)
    mov rax, [rsi+9]
    jmp .return

.wrong_type:
    mov rax,SOB_VOID_ADDRESS
.return:
    leave
    ret

set_cdr:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]
    cmp sil, T_PAIR
    jne .wrong_type
    mov rsi, PVAR(0)
    mov rcx, PVAR(1)
    mov [rsi+9], rcx
    jmp .return

.wrong_type:
    mov rax,SOB_VOID_ADDRESS
.return:
    mov rax,SOB_VOID_ADDRESS
    leave
    ret

cons_func:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov rcx, PVAR(1)
    MAKE_PAIR (rax,rsi,rcx)
    
    leave
    ret

apply_func:
      push rbp
      mov rbp, rsp

      mov rsi, PVAR(0)                          ; check if PVAR(0) is closure
      cmp byte[rsi], T_CLOSURE
      jne 0xbad

      mov r13, qword [rbp]                      ; holds old_rbp
      mov r12, PVAR(0)                          ; holds closure

      mov rcx, [rbp + 8 * 3]        
      mov r9, PVAR(rcx - 1)
      mov r8, SOB_NIL_ADDRESS        

      mov rdi, r9
      cmp rdi, SOB_NIL_ADDRESS
      je .apply_reverse_list_created

      .apply_reverse_list:
          CAR rdi, r9
          MAKE_PAIR (rsi,rdi,r8)
          mov r8, rsi
          CDR rsi,r9
          mov r9, rsi
          cmp rsi, SOB_NIL_ADDRESS
          jne .apply_reverse_list               ; r8 is reversed list
                
      .apply_reverse_list_created:    
      mov r14, 0                                ; r14 holds list size 
      
      mov rdi, r8
      cmp rdi, SOB_NIL_ADDRESS
      je .apply_reverse_list_push_finished      ; check if reversed list is nil

      .apply_reverse_list_push:
          CAR rdi, r8
          push rdi
          CDR rsi, r8
          mov r8 , rsi
          inc r14
          cmp rsi, SOB_NIL_ADDRESS
          jne .apply_reverse_list_push          ; r8 is nil and all of it's args pushed
        
      .apply_reverse_list_push_finished: 
      mov rcx , [rbp+3*8]                       ; old frame arg number
      sub rcx, 2                                ; 1 for list, 1 for PVAR(0) = function
      mov r8, rcx
      cmp r8, 0
      je .apply_finish_push_args                ; there is no args to push

      .apply_push_args:
          push PVAR(rcx)
          loop .apply_push_args

    .apply_finish_push_args:                    ; push regulars
    sub r14, 2
    add r14, [rbp+3*8]
    push r14                                    ; pushed fixed size of args = old args + list size - 1 (for list) - 1 (for func)

    mov rdi,r12
    CLOSURE_ENV rsi,rdi
    push rsi                                    ; pushed PVAR(0) env

    push qword[rbp+1*8]                         ; pushed ret addr
        
    ;;;;FINISHED PUSHING - FIX THE STACK;;;;
    
    mov r14, [rbp+3*8]                          ; r14 <- old args num
    add r14, 3
    shl r14, 3
    add r14, rbp                                ; r14 <- old frame last arg address =  [rbp + 3 * 8 + old_arg_num * 8]
    mov rcx, [rsp+2*8]                          ; new arg number 
    add rcx, 3                                  ; for arg num , env, return addr

    .apply_override_frame:
        mov r8, [rsp+(2+rcx-3)*8]
        mov [r14], r8
        sub r14, 8
        loop .apply_override_frame

    mov rbp, r13                                ; r13 hold old_rbp
    add r14,8                                   ; fix r14 point to ret addr
    mov rsp, r14                                ; fix rsp
    
    CLOSURE_CODE rdi,r12                        ; rdi hold closure
    jmp rdi
    leave 
    ret
        ";;

exception X_missing_input_file;;

try
  let infile = Sys.argv.(1) in
  let code =  (file_to_string "stdlib.scm") ^ (file_to_string infile) in
  let asts = string_to_asts code in
  let consts_tbl = Code_Gen.make_consts_tbl asts in
  let fvars_tbl = Code_Gen.make_fvars_tbl asts in
  let generate = Code_Gen.generate consts_tbl fvars_tbl in
  let code_fragment = String.concat "\n\n"
                        (List.map
                           (fun ast -> (generate ast) ^ "\n    call write_sob_if_not_void")
                           asts) in
  let provided_primitives = file_to_string "prims.s" in
                   
  print_string ((make_prologue consts_tbl fvars_tbl) ^
                    "\n   push rbp\n  mov rbp ,rsp\n" ^
                        code_fragment ^
                            "\n leave\n   ret\n\n" ^
            provided_primitives ^ "\n" ^ epilogue)
with Invalid_argument(x) -> raise X_missing_input_file;;
